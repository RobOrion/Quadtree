
#load "str.cma" ;;

let rec lire = function(fichier) ->
          let i = input_line(fichier) in
                    i::lire(fichier)
                    with End_of_file -> [];;

let ligne l = Str.split (Str.regexp " ") l;;

let path = open_in "nom_du_fichier";;

seek_in path 0;;

let f = lire path;;

let b = List.map ligne f;;

Noeud =
(*création d'un noeud*)

let creerArbre (v,f1,f2,f3,f4) = Noeud (v,f1,f2,f3,f4);;

exception Arbre_vide;;

let getRacine a = match a with
              Nul -> raise Arbre_vide
              |Noeud (v,_,_,_,_) -> v;;

let TailleImage = open_in "image.ppm";;

let rec longueurListe(l) =
        if tl(l) = [ ] then 1
        else 1 + longueurListe(List.tl(l));;

let rec inserer a x = match a with
          Nul -> Noeud (Nul,x,Nul)
          | Noeud (fg,r,fd) ->
          if x=r then a else
          if x>r then Noeud (fg,r,inserer fd x)
          else Noeud (inserer fg x,r,fd);;
 
let moithaut l =
          let rec traitement m l =
                            if (m >= (List.length l )) then []
                            else ( (List.hd l)::(traitement (m+1) (List.tl l)) ) in traitement 0 l ;;

let moitbas l =
          let rec traitement m l =
                            if (m >= (List.length l )) then l
                            else (traitement (m+1) (List.tl l))  in traitement 0 l ;;

let hautgauche l =
          let rec quart1 l m = match l with
                          [] -> []
                          |_ -> if List.length mod 2 = 0 then (moitbas (List.hd(l)))::quart1(List.tl(l)) (List.length div 2) in (quart1(moithaut l) 0)
                                else (moitbas (List.hd(l)))::quart1(List.tl(l)) ((List.length div 2)+1) in (quart1(moithaut l) 0);;
/à modifier/
let hautdroit l =
          let rec quart2 l m = match l with
                          [] -> []
                          |_ ->  (moitbas (List.hd(l)))::quart1(List.tl(l)) (m+1) in quart1(moithaut l) 0;;
/à modifier/
let basgauche l =
          let rec quart3 l m = match l with
                          [] -> if List.length mod 2 = 0 then (moithaut (List.hd(l)))::quart1(List.tl(l)) (List.length div 2) in (quart1(moitbas l) 0)
                                else (moithaut (List.hd(l)))::quart1(List.tl(l)) ((List.length div 2)+1) in (quart1(moitbas l) 0);;

let basdroit l =
          let rec quart4 l m = match l with
                          [] -> []
                          |_ -> (moithaut (List.hd(l)))::quart4(List.tl(l)) (m+1) in quart4 (moitbas l) 0;;

let liste1 = hautgauche l;;
let liste2 = hautdroit l;;
let liste3 = basgauche l;;
let liste4 = basdroit l;;

let rec inverser l = match l with
          []-> []
          |a::[] -> [1::a]
          |a::r -> [1::a]@inverser r ;;

let rec sommeListePixelBinaire l = match l with
          []-> 0
          |([i])::([])-> l
          |([i])::([j])::r -> (i + j + sommeListePixelBinaire r);;

let moyenneFinaleListeBin l = (sommeListePixelBinaire(l))/ (longueurListe l);;

let moyenneListePixel a = [a];;

let rec creationArbre l f = match l with
          []-> Nul
          |a::[] -> creerArbre(moyenneListePixel(moyenneFinaleListeBin(l))) Nul Nul Nul Nul
          |a::r -> match (egalite l) with
                  true -> creerArbre (moyenneListePixel (finalmoyennelistepixelBinaire l)) Nul Nul Nul Nul
                  |false -> creerArbre (moyenneListePixel (finalmoyennelistepixelBinaire l)) (creationArbre (liste1 l (f)) (f/2)) (creationArbre (liste2 l (f)) (f/2)) (creationArbre (liste3 l (f)) (f/2)) (creationArbre (liste4 l (f)) (f/2));;

let arbreComplet = creationArbre (liste taille);;

let rec miroir (longueurListe(l))(l) =
    if 1 = n then hd(l) :: [ ]
    else
          let rec recu(n)(l) =
                        if n = 1
                            then hd(l)
                            else recu(n-1)(tl(l))
                in recu(n)(l) :: miroir(n-1)(l));;

let rotDroite a = match a with
          Noeud (Noeud(u,p,v),q,w) -> Noeud (u,p,Noeud (v,q,w))
          |_  -> failwith "rotation impossible" ;;

let rotGauche a = match a with
          Noeud (u,p,Noeud(v,q,w)) -> Noeud (Noeud (u,p,v),q,w)
          |_ -> failwith  "rotation impossible" ;;

let inverspixel pixel = {r=255 - pixel.r ; g= 255 - pixel.g ; b = 255 - pixel.b};;
